/* -*- c++ -*- */
/*
 * Copyright 2004 Free Software Foundation, Inc.
 * 
 * This file is part of GNU Radio
 * 
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 * 
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <es/es.h>
#include <gr_io_signature.h>
#include <stdio.h>

/*
 * Create a new instance of es_sink and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
es_sink_sptr 
es_make_sink (pmt_t arb, es_queue_sptr queue, gr_io_signature_sptr insig, int n_threads)
{
  return es_sink_sptr (new es_sink (arb,queue,insig,n_threads));
}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr_block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 1 input and 1 output.
 */
static const int MIN_OUT = 0;	// minimum number of output streams
static const int MAX_OUT = 0;	// maximum number of output streams

/*
 * The private constructor
 */
es_sink::es_sink (pmt_t _arb, es_queue_sptr _queue, gr_io_signature_sptr insig, int _n_threads) 
  : gr_sync_block ("es_sink",
           insig,
		   gr_make_io_signature (MIN_OUT, MAX_OUT, 0)), event_queue(_queue), arb(_arb), n_threads(_n_threads)
{
    d_time = 0;
    d_history = 1024*64;
    set_history(d_history);

    // instantiate the threadpool workers
    for(int i=0; i<n_threads; i++){
        boost::shared_ptr<es_event_loop_thread> th( new es_event_loop_thread(arb, event_queue, &qq, &dq, &qq_cond) );
        threadpool.push_back( th );
    }

}

/*
 * Our virtual destructor.
 */
es_sink::~es_sink ()
{
    for(int i=0; i<n_threads; i++){
        threadpool[i]->stop();
    }
}


int 
es_sink::work (int noutput_items,
			gr_vector_const_void_star &input_items,
			gr_vector_void_star &output_items)
{
  char *in = (char*) input_items[0];
 
  printf("entered es_sink::work()\n");
  // compute the min and max sample times currently accessible in the buffer
  unsigned long long max_time = d_time + noutput_items;
  unsigned long long min_time = (d_history > d_time)?0:d_time-d_history;

  // generate an empty event sptr
  es_eh_pair *eh = NULL;
  
  unsigned long long delete_index;
  while( dq.dequeue(&delete_index) ){
    printf(" removing live_time %llu \n", delete_index);
    assert(0);
    }


  // while we can service events with the current buffer, get them and handle them.
  while( event_queue->fetch_next_event( min_time, max_time, &eh ) ){

    printf("es_sink::work()::fetched event successfully.\n");
    pmt_t event = eh->event;

    // compute the local buffer offset of the event
    int buffer_offset = eh->time() - d_time + d_history - 1;
    pmt_t buf_list = PMT_NIL;
    bool first_item = true;

    // loop over each input buffer copying contents into pmt_buffers to tag onto event
    for(int i=0; i<input_items.size(); i++){

        // alocate a new pmt u8 vector to store buffer contents in.       
        pmt_t buf_i = pmt_init_u8vector( d_input_signature->sizeof_stream_item(i)*eh->length(), (const uint8_t*) input_items[i] + (buffer_offset * d_input_signature->sizeof_stream_item(i)) );

        // build up a pmt list containing pmt_u8vectors with all the buffers
        if(first_item){
            buf_list = pmt_list1( buf_i );
            first_item = false;
        } else {
            pmt_list_add(buf_list, buf_i);
        }

    }

    // register the buffer in the event
    event = register_buffer( event, buf_list );
    eh->event = event;

    // post the event to the event-loop input queue  
    printf("es_sink::work()::posting event to event loop queue (qq) with buffer.\n");
    qq.enqueue(eh);
    qq_cond.notify_one();

  }

  // consume the current input items
  return noutput_items;
}


