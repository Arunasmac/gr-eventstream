/* -*- c++ -*- */
/*
 * Copyright 2011 Free Software Foundation, Inc.
 * 
 * This file is part of gr-eventstream
 * 
 * gr-eventstream is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 * 
 * gr-eventstream is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with gr-eventstream; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <es/es_source2.h>
#include <es/es_common.h>
#include <es/es_queue.h>
#include <es/es.h>
#include <gr_io_signature.h>
#include <stdio.h>
#include <string.h>

//#define DEBUG(x) x
#define DEBUG(x)

/*
 * Create a new instance of es_source2 and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
es_source2_sptr 
es_make_source2 (pmt_t arb, es_queue_sptr queue, gr_vector_int out_sig)
{
  return es_source2_sptr (new es_source2 (arb,queue,out_sig));
}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr_block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 1 input and 1 output.
 */
static const int MIN_IN = 0;	// mininum number of input streams
static const int MAX_IN = 0;	// maximum number of input streams

unsigned long long es_source2::time(){
    return d_time;
}

/*
 * The private constructor
 */
es_source2::es_source2 (pmt_t _arb, es_queue_sptr _queue, gr_vector_int out_sig)
  : gr_sync_block ("es_source2",
    gr_make_io_signature (MIN_IN, MAX_IN, 0),
    es_make_io_signature (out_sig.size(), out_sig) ),
    event_queue(_queue), 
    arb(_arb),
    d_maxlen(ULLONG_MAX),
    d_time(0),
    n_threads(2) // poke this through as a constructor arg
{
    //event_queue->set_append_callback( self );
    // create and dispatch handler threads
    for(int i=0; i<n_threads; i++){
        boost::shared_ptr<es_source_thread> th( new es_source_thread(arb, event_queue, &qq, &lin_mut, &readylist, &qq_cond, out_sig) );
        threadpool.push_back( th );
    }

    // bind event_queue->append() callback function
    boost::function< bool(es_eh_pair**) > f;
    f = std::bind1st(std::mem_fun(&es_source2::cb), this);
    event_queue->set_append_callback( f );
}


// callback bound to the es_queue add_item routine (executed for each new eh pair)
bool es_source2::cb(es_eh_pair** eh){
    
    printf("es_source2::cb() executing.\n");

    // pass eh pair to lockfree fifos (out to threads)
    es_eh_pair * tp = *eh;
    qq.enqueue(tp);
    qq_cond.notify_one(); // notify one of the sleeping threads (if any)
    
    // we dont need this event anymore in the main queue
    return false;
}


// set a maximum number of items to produce (otherwise we will run forever and never mark finished)
void es_source2::set_max(unsigned long long maxlen){
    d_maxlen = maxlen;
}

/*
 * Our virtual destructor.
 */
es_source2::~es_source2 ()
{
    // TODO: move this to stop() instead?
    //shutdown threads
    for(int i=0; i<n_threads; i++){
        threadpool[i]->stop();
    }
}

int 
es_source2::work (int noutput_items,
			gr_vector_const_void_star &input_items,
			gr_vector_void_star &output_items)
{
  char *out = (char *) output_items[0];
  printf("entered work.\n");
  printf("d_time = %llu, noutput_items = %d\n", d_time, noutput_items);  
  

  unsigned long long max_time = d_time + noutput_items;
  unsigned long long min_time = d_time;

  // zero the output buffers
  for(int j=0; j<output_items.size();j++){
      int itemsize = d_output_signature->sizeof_stream_item(j);
      memset(output_items[j], 0x00, noutput_items*itemsize);
  }
  
  // acquire the readylist lock
  lin_mut.lock();

  // grab serialized buffers from thread output
  //        copy buffers into work output buffer
  
  std::vector<pmt_t>::iterator it;
  //for(it = readylist.begin(); it != readylist.end(); ){
  for(int i = 0; i<readylist.size(); i++){
    printf("readylist[%d] = %x\n", i, readylist[i].get());
    pmt_t evt = readylist[i];
    printf("iterating over ready list (i=%d, evt_time = %llu).\n",i,event_time(evt));

    
    printf("erased vector reference. (%llu, %d)\n",event_time(evt),event_length(evt));
    
    uint64_t e_time = event_time(evt);
    uint64_t e_length = event_length(evt);
    

    if(e_time >= d_time + noutput_items){ // event starts after our current buffer area save for later
        break; // if event is in the future do nothing with it (since they are time ordered - we are done here)
    } else { // event starts in our buffer, or in the past
        if(e_time < d_time){ // if event starts in the past handle the behavior appropriately
            switch(event_queue->d_early_behavior){
                case BALK:
                    printf("event arrived scheduled before allowed buffer!\n");
                    perror("");
                    break;
                case ASAP:
                    // update event time to be as soon as possible
                    evt = event_args_add(evt, pmt_intern("es::event_time") , pmt_from_uint64(d_time));
                    e_time = event_time(evt);
                    printf("updating event time.\n");
            }
        }
        // remove the event we are handling
        readylist.erase(readylist.begin()+i);
        i--;

        // if we reach this point, we will be generating output from this event
        // compute portion of event to output
        int space_avail = d_time + noutput_items - e_time;
        int item_copy = (space_avail >= e_length ? e_length : space_avail); //TODO: this may cause issues for large events
        printf("space_avail = %d, e_length = %d, item_copy = %d\n", space_avail, e_length, item_copy);
        printf("d_time = %llu, e_time = %llu, noutput_items = %d\n", d_time, e_time, noutput_items);

        // compute copy offsets
        int output_offset = 0;
        int input_offset = 0;
        if(e_time >= d_time){
            // event starts at non zero offset in buffer
            output_offset = e_time - d_time;
        } else {
            // event starts in the past (copy only the end region)
            input_offset = d_time - e_time;
        }

        // (*it) == event
        // TODO: error checking on this ?
        printf("making sure buffer list arg exists\n");
        if( !event_has_field( (evt), es::event_buffer ) ){
            perror("malformed event");
            }
        printf("getting buffer list element\n");

        // buf_list is a pmt_list of pmt_blobs containing buffers for N output ports
        pmt_t buf_list = event_field( (evt), es::event_buffer ); 
        printf("buf has %d elements.\n", pmt_length(buf_list) );

        // sanity checking
        if( (!(item_copy <= input_offset+noutput_items)) || (!(input_offset >= 0)) ){
            perror("insane offsets\n");
        }

        // copy to output buffer (iterate over number of output ports)
        for(int j=0; j<output_items.size();j++){

            printf("getting %d'th buffer\n", j);
            pmt_t buf = pmt_nth(j, buf_list);           

            printf("got buf\n");

            // get reference to buffer stored in the event
            const char* ii = (const char*) pmt_blob_data(buf);

            // get reference to the output buffer
            char* oo = (char*) output_items[j];
            int itemsize = d_output_signature->sizeof_stream_item(j);

            printf("calling memcpy\n");
            // copy memory from event args to output buffer
            printf("calling memcpy from ii=%x to oo=%x\n", ii, oo);
            printf("memcpy length = %d\n", item_copy*itemsize);
            printf("output_offset = %d, input_offset = %d\n", output_offset, input_offset);
            memcpy( &oo[output_offset*itemsize], &ii[input_offset*itemsize], item_copy*itemsize );
            printf("memcpy returned\n");
        }

        printf("e_length = %d, item_copy = %d\n", e_length, item_copy);

        // if we have leftovers to store (from previous work executions)
        if(e_length > item_copy){

            printf("generating continuation event for next time.\n");

            // generate a new event to represent the remaining contents which have not yet been output
            pmt_t evt_c = event_create( "CONTINUATION", e_time + item_copy, e_length - item_copy );
            pmt_t outbuf_list;

            // populate the event with remaining buffer contents
            // create a pmt_list with pointers to existing buffers
            // no new mallocing should happen here
            for(int j=0; j<output_items.size();j++){ //iterate over number of output ports
                int itemsize = d_output_signature->sizeof_stream_item(j);

                // get a reference to our blob of interest in the blob list
                pmt_t buf = pmt_nth(j, buf_list);           
                const char* base_srcptr = (const char*) pmt_blob_data(buf);

                // make a new blob pointing to a portion of the old blob
                pmt_t newblob = pmt_make_blob( base_srcptr + itemsize * item_copy, itemsize*(event_length(evt)-item_copy));
                if(j==0){
                    outbuf_list = pmt_list1( newblob );
                } else {
                    outbuf_list = pmt_list_add( outbuf_list, newblob );
                }
            }
 
            // tag the new buffers onto the event
            printf("register buffer.\n");
            evt_c = register_buffer( evt_c, outbuf_list );

            // the original buffers are saved to make sure we reserve the pmt_blobs allocation!           
            static const pmt_t ORIG_FLAG(pmt_intern("SAVE_ORIG_BUFS"));
            if(event_has_field(evt, ORIG_FLAG)){
                evt_c = event_args_add( evt_c, ORIG_FLAG, event_field( evt, ORIG_FLAG ) );
            } else {
                evt_c = event_args_add( evt_c, ORIG_FLAG, event_field( evt, es::event_buffer ) );
            }
 
            printf("inserting into readylist (readylist.size() = %d).\n",readylist.size());
            // insert the new event into our readylist
            for(int k=0; k<=readylist.size(); k++){
                if(k == readylist.size()){
                    readylist.insert( readylist.begin()+k, evt_c );
                    printf("inserting into end of readylist (%llu,%d).\n",
                            event_time(evt_c), event_length(evt_c));
                    break;
                } else if( event_time(evt_c) < event_time(readylist[k]) ){
                    readylist.insert( readylist.begin()+k, evt_c );
                    printf("inserting into %d of readylist.\n",k);
                    break;
                } else {
                    printf("insert failed!\n");
                }
                
            } // done inserting
        } // done leftover exists conditional
    } // done time range if()
    printf("e { time: %llu, length: %llu }\n", e_time, e_length);
    } // done outer loop over readylist contents


  lin_mut.unlock();
 
  
  // determine number to be produced
//  printf("d_maxlen = %llu, d_time = %llu, noutput_items = %d\n", d_maxlen, d_time, noutput_items);
  int produced = (d_maxlen < d_time + noutput_items)?d_maxlen - d_time:noutput_items;
  printf("*** produced = %llu\n", produced);
  d_time += produced; // step time ptr along
  return produced;
}
